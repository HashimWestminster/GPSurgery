{"ast":null,"code":"import { nodeListForEach } from '../../common/index.mjs';\nimport '../../vendor/polyfills/Element/prototype/classList.mjs';\nimport '../../vendor/polyfills/Event.mjs';\nimport '../../vendor/polyfills/Function/prototype/bind.mjs';\n\n/* eslint-disable es-x/no-function-prototype-bind -- Polyfill imported */\n\n/**\n * Radios component\n *\n * @class\n * @param {Element} $module - HTML element to use for radios\n */\nfunction Radios($module) {\n  if (!($module instanceof HTMLElement)) {\n    return this;\n  }\n  var $inputs = $module.querySelectorAll('input[type=\"radio\"]');\n  if (!$inputs.length) {\n    return this;\n  }\n\n  /** @deprecated Will be made private in v5.0 */\n  this.$module = $module;\n\n  /** @deprecated Will be made private in v5.0 */\n  this.$inputs = $inputs;\n}\n\n/**\n * Initialise component\n *\n * Radios can be associated with a 'conditionally revealed' content block – for\n * example, a radio for 'Phone' could reveal an additional form field for the\n * user to enter their phone number.\n *\n * These associations are made using a `data-aria-controls` attribute, which is\n * promoted to an aria-controls attribute during initialisation.\n *\n * We also need to restore the state of any conditional reveals on the page (for\n * example if the user has navigated back), and set up event handlers to keep\n * the reveal in sync with the radio state.\n */\nRadios.prototype.init = function () {\n  // Check that required elements are present\n  if (!this.$module || !this.$inputs) {\n    return;\n  }\n  var $module = this.$module;\n  var $inputs = this.$inputs;\n  nodeListForEach($inputs, function ($input) {\n    var targetId = $input.getAttribute('data-aria-controls');\n\n    // Skip radios without data-aria-controls attributes, or where the\n    // target element does not exist.\n    if (!targetId || !document.getElementById(targetId)) {\n      return;\n    }\n\n    // Promote the data-aria-controls attribute to a aria-controls attribute\n    // so that the relationship is exposed in the AOM\n    $input.setAttribute('aria-controls', targetId);\n    $input.removeAttribute('data-aria-controls');\n  });\n\n  // When the page is restored after navigating 'back' in some browsers the\n  // state of form controls is not restored until *after* the DOMContentLoaded\n  // event is fired, so we need to sync after the pageshow event in browsers\n  // that support it.\n  window.addEventListener('onpageshow' in window ? 'pageshow' : 'DOMContentLoaded', this.syncAllConditionalReveals.bind(this));\n\n  // Although we've set up handlers to sync state on the pageshow or\n  // DOMContentLoaded event, init could be called after those events have fired,\n  // for example if they are added to the page dynamically, so sync now too.\n  this.syncAllConditionalReveals();\n\n  // Handle events\n  $module.addEventListener('click', this.handleClick.bind(this));\n};\n\n/**\n * Sync the conditional reveal states for all radio buttons in this $module.\n *\n * @deprecated Will be made private in v5.0\n */\nRadios.prototype.syncAllConditionalReveals = function () {\n  nodeListForEach(this.$inputs, this.syncConditionalRevealWithInputState.bind(this));\n};\n\n/**\n * Sync conditional reveal with the input state\n *\n * Synchronise the visibility of the conditional reveal, and its accessible\n * state, with the input's checked state.\n *\n * @deprecated Will be made private in v5.0\n * @param {HTMLInputElement} $input - Radio input\n */\nRadios.prototype.syncConditionalRevealWithInputState = function ($input) {\n  var targetId = $input.getAttribute('aria-controls');\n  if (!targetId) {\n    return;\n  }\n  var $target = document.getElementById(targetId);\n  if ($target && $target.classList.contains('govuk-radios__conditional')) {\n    var inputIsChecked = $input.checked;\n    $input.setAttribute('aria-expanded', inputIsChecked.toString());\n    $target.classList.toggle('govuk-radios__conditional--hidden', !inputIsChecked);\n  }\n};\n\n/**\n * Click event handler\n *\n * Handle a click within the $module – if the click occurred on a radio, sync\n * the state of the conditional reveal for all radio buttons in the same form\n * with the same name (because checking one radio could have un-checked a radio\n * in another $module)\n *\n * @deprecated Will be made private in v5.0\n * @param {MouseEvent} event - Click event\n */\nRadios.prototype.handleClick = function (event) {\n  var $component = this;\n  var $clickedInput = event.target;\n\n  // Ignore clicks on things that aren't radio buttons\n  if (!($clickedInput instanceof HTMLInputElement) || $clickedInput.type !== 'radio') {\n    return;\n  }\n\n  // We only need to consider radios with conditional reveals, which will have\n  // aria-controls attributes.\n  var $allInputs = document.querySelectorAll('input[type=\"radio\"][aria-controls]');\n  var $clickedInputForm = $clickedInput.form;\n  var $clickedInputName = $clickedInput.name;\n  nodeListForEach($allInputs, function ($input) {\n    var hasSameFormOwner = $input.form === $clickedInputForm;\n    var hasSameName = $input.name === $clickedInputName;\n    if (hasSameName && hasSameFormOwner) {\n      $component.syncConditionalRevealWithInputState($input);\n    }\n  });\n};\nexport default Radios;","map":{"version":3,"names":["nodeListForEach","Radios","$module","HTMLElement","$inputs","querySelectorAll","length","prototype","init","$input","targetId","getAttribute","document","getElementById","setAttribute","removeAttribute","window","addEventListener","syncAllConditionalReveals","bind","handleClick","syncConditionalRevealWithInputState","$target","classList","contains","inputIsChecked","checked","toString","toggle","event","$component","$clickedInput","target","HTMLInputElement","type","$allInputs","$clickedInputForm","form","$clickedInputName","name","hasSameFormOwner","hasSameName"],"sources":["C:/Users/thami/Documents/21W- Local Software Dev Group Project/medicalRecordsV2/node_modules/govuk-frontend/govuk-esm/components/radios/radios.mjs"],"sourcesContent":["import { nodeListForEach } from '../../common/index.mjs';\nimport '../../vendor/polyfills/Element/prototype/classList.mjs';\nimport '../../vendor/polyfills/Event.mjs';\nimport '../../vendor/polyfills/Function/prototype/bind.mjs';\n\n/* eslint-disable es-x/no-function-prototype-bind -- Polyfill imported */\n\n/**\n * Radios component\n *\n * @class\n * @param {Element} $module - HTML element to use for radios\n */\nfunction Radios ($module) {\n  if (!($module instanceof HTMLElement)) {\n    return this\n  }\n\n  var $inputs = $module.querySelectorAll('input[type=\"radio\"]');\n  if (!$inputs.length) {\n    return this\n  }\n\n  /** @deprecated Will be made private in v5.0 */\n  this.$module = $module;\n\n  /** @deprecated Will be made private in v5.0 */\n  this.$inputs = $inputs;\n}\n\n/**\n * Initialise component\n *\n * Radios can be associated with a 'conditionally revealed' content block – for\n * example, a radio for 'Phone' could reveal an additional form field for the\n * user to enter their phone number.\n *\n * These associations are made using a `data-aria-controls` attribute, which is\n * promoted to an aria-controls attribute during initialisation.\n *\n * We also need to restore the state of any conditional reveals on the page (for\n * example if the user has navigated back), and set up event handlers to keep\n * the reveal in sync with the radio state.\n */\nRadios.prototype.init = function () {\n  // Check that required elements are present\n  if (!this.$module || !this.$inputs) {\n    return\n  }\n\n  var $module = this.$module;\n  var $inputs = this.$inputs;\n\n  nodeListForEach($inputs, function ($input) {\n    var targetId = $input.getAttribute('data-aria-controls');\n\n    // Skip radios without data-aria-controls attributes, or where the\n    // target element does not exist.\n    if (!targetId || !document.getElementById(targetId)) {\n      return\n    }\n\n    // Promote the data-aria-controls attribute to a aria-controls attribute\n    // so that the relationship is exposed in the AOM\n    $input.setAttribute('aria-controls', targetId);\n    $input.removeAttribute('data-aria-controls');\n  });\n\n  // When the page is restored after navigating 'back' in some browsers the\n  // state of form controls is not restored until *after* the DOMContentLoaded\n  // event is fired, so we need to sync after the pageshow event in browsers\n  // that support it.\n  window.addEventListener(\n    'onpageshow' in window ? 'pageshow' : 'DOMContentLoaded',\n    this.syncAllConditionalReveals.bind(this)\n  );\n\n  // Although we've set up handlers to sync state on the pageshow or\n  // DOMContentLoaded event, init could be called after those events have fired,\n  // for example if they are added to the page dynamically, so sync now too.\n  this.syncAllConditionalReveals();\n\n  // Handle events\n  $module.addEventListener('click', this.handleClick.bind(this));\n};\n\n/**\n * Sync the conditional reveal states for all radio buttons in this $module.\n *\n * @deprecated Will be made private in v5.0\n */\nRadios.prototype.syncAllConditionalReveals = function () {\n  nodeListForEach(this.$inputs, this.syncConditionalRevealWithInputState.bind(this));\n};\n\n/**\n * Sync conditional reveal with the input state\n *\n * Synchronise the visibility of the conditional reveal, and its accessible\n * state, with the input's checked state.\n *\n * @deprecated Will be made private in v5.0\n * @param {HTMLInputElement} $input - Radio input\n */\nRadios.prototype.syncConditionalRevealWithInputState = function ($input) {\n  var targetId = $input.getAttribute('aria-controls');\n  if (!targetId) {\n    return\n  }\n\n  var $target = document.getElementById(targetId);\n  if ($target && $target.classList.contains('govuk-radios__conditional')) {\n    var inputIsChecked = $input.checked;\n\n    $input.setAttribute('aria-expanded', inputIsChecked.toString());\n    $target.classList.toggle('govuk-radios__conditional--hidden', !inputIsChecked);\n  }\n};\n\n/**\n * Click event handler\n *\n * Handle a click within the $module – if the click occurred on a radio, sync\n * the state of the conditional reveal for all radio buttons in the same form\n * with the same name (because checking one radio could have un-checked a radio\n * in another $module)\n *\n * @deprecated Will be made private in v5.0\n * @param {MouseEvent} event - Click event\n */\nRadios.prototype.handleClick = function (event) {\n  var $component = this;\n  var $clickedInput = event.target;\n\n  // Ignore clicks on things that aren't radio buttons\n  if (!($clickedInput instanceof HTMLInputElement) || $clickedInput.type !== 'radio') {\n    return\n  }\n\n  // We only need to consider radios with conditional reveals, which will have\n  // aria-controls attributes.\n  var $allInputs = document.querySelectorAll('input[type=\"radio\"][aria-controls]');\n\n  var $clickedInputForm = $clickedInput.form;\n  var $clickedInputName = $clickedInput.name;\n\n  nodeListForEach($allInputs, function ($input) {\n    var hasSameFormOwner = $input.form === $clickedInputForm;\n    var hasSameName = $input.name === $clickedInputName;\n\n    if (hasSameName && hasSameFormOwner) {\n      $component.syncConditionalRevealWithInputState($input);\n    }\n  });\n};\n\nexport default Radios;\n//# sourceMappingURL=components/radios/radios.mjs.map\n"],"mappings":"AAAA,SAASA,eAAe,QAAQ,wBAAwB;AACxD,OAAO,wDAAwD;AAC/D,OAAO,kCAAkC;AACzC,OAAO,oDAAoD;;AAE3D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,MAAMA,CAAEC,OAAO,EAAE;EACxB,IAAI,EAAEA,OAAO,YAAYC,WAAW,CAAC,EAAE;IACrC,OAAO,IAAI;EACb;EAEA,IAAIC,OAAO,GAAGF,OAAO,CAACG,gBAAgB,CAAC,qBAAqB,CAAC;EAC7D,IAAI,CAACD,OAAO,CAACE,MAAM,EAAE;IACnB,OAAO,IAAI;EACb;;EAEA;EACA,IAAI,CAACJ,OAAO,GAAGA,OAAO;;EAEtB;EACA,IAAI,CAACE,OAAO,GAAGA,OAAO;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAH,MAAM,CAACM,SAAS,CAACC,IAAI,GAAG,YAAY;EAClC;EACA,IAAI,CAAC,IAAI,CAACN,OAAO,IAAI,CAAC,IAAI,CAACE,OAAO,EAAE;IAClC;EACF;EAEA,IAAIF,OAAO,GAAG,IAAI,CAACA,OAAO;EAC1B,IAAIE,OAAO,GAAG,IAAI,CAACA,OAAO;EAE1BJ,eAAe,CAACI,OAAO,EAAE,UAAUK,MAAM,EAAE;IACzC,IAAIC,QAAQ,GAAGD,MAAM,CAACE,YAAY,CAAC,oBAAoB,CAAC;;IAExD;IACA;IACA,IAAI,CAACD,QAAQ,IAAI,CAACE,QAAQ,CAACC,cAAc,CAACH,QAAQ,CAAC,EAAE;MACnD;IACF;;IAEA;IACA;IACAD,MAAM,CAACK,YAAY,CAAC,eAAe,EAAEJ,QAAQ,CAAC;IAC9CD,MAAM,CAACM,eAAe,CAAC,oBAAoB,CAAC;EAC9C,CAAC,CAAC;;EAEF;EACA;EACA;EACA;EACAC,MAAM,CAACC,gBAAgB,CACrB,YAAY,IAAID,MAAM,GAAG,UAAU,GAAG,kBAAkB,EACxD,IAAI,CAACE,yBAAyB,CAACC,IAAI,CAAC,IAAI,CAAC,CAC1C;;EAED;EACA;EACA;EACA,IAAI,CAACD,yBAAyB,EAAE;;EAEhC;EACAhB,OAAO,CAACe,gBAAgB,CAAC,OAAO,EAAE,IAAI,CAACG,WAAW,CAACD,IAAI,CAAC,IAAI,CAAC,CAAC;AAChE,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAlB,MAAM,CAACM,SAAS,CAACW,yBAAyB,GAAG,YAAY;EACvDlB,eAAe,CAAC,IAAI,CAACI,OAAO,EAAE,IAAI,CAACiB,mCAAmC,CAACF,IAAI,CAAC,IAAI,CAAC,CAAC;AACpF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAlB,MAAM,CAACM,SAAS,CAACc,mCAAmC,GAAG,UAAUZ,MAAM,EAAE;EACvE,IAAIC,QAAQ,GAAGD,MAAM,CAACE,YAAY,CAAC,eAAe,CAAC;EACnD,IAAI,CAACD,QAAQ,EAAE;IACb;EACF;EAEA,IAAIY,OAAO,GAAGV,QAAQ,CAACC,cAAc,CAACH,QAAQ,CAAC;EAC/C,IAAIY,OAAO,IAAIA,OAAO,CAACC,SAAS,CAACC,QAAQ,CAAC,2BAA2B,CAAC,EAAE;IACtE,IAAIC,cAAc,GAAGhB,MAAM,CAACiB,OAAO;IAEnCjB,MAAM,CAACK,YAAY,CAAC,eAAe,EAAEW,cAAc,CAACE,QAAQ,EAAE,CAAC;IAC/DL,OAAO,CAACC,SAAS,CAACK,MAAM,CAAC,mCAAmC,EAAE,CAACH,cAAc,CAAC;EAChF;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAxB,MAAM,CAACM,SAAS,CAACa,WAAW,GAAG,UAAUS,KAAK,EAAE;EAC9C,IAAIC,UAAU,GAAG,IAAI;EACrB,IAAIC,aAAa,GAAGF,KAAK,CAACG,MAAM;;EAEhC;EACA,IAAI,EAAED,aAAa,YAAYE,gBAAgB,CAAC,IAAIF,aAAa,CAACG,IAAI,KAAK,OAAO,EAAE;IAClF;EACF;;EAEA;EACA;EACA,IAAIC,UAAU,GAAGvB,QAAQ,CAACP,gBAAgB,CAAC,oCAAoC,CAAC;EAEhF,IAAI+B,iBAAiB,GAAGL,aAAa,CAACM,IAAI;EAC1C,IAAIC,iBAAiB,GAAGP,aAAa,CAACQ,IAAI;EAE1CvC,eAAe,CAACmC,UAAU,EAAE,UAAU1B,MAAM,EAAE;IAC5C,IAAI+B,gBAAgB,GAAG/B,MAAM,CAAC4B,IAAI,KAAKD,iBAAiB;IACxD,IAAIK,WAAW,GAAGhC,MAAM,CAAC8B,IAAI,KAAKD,iBAAiB;IAEnD,IAAIG,WAAW,IAAID,gBAAgB,EAAE;MACnCV,UAAU,CAACT,mCAAmC,CAACZ,MAAM,CAAC;IACxD;EACF,CAAC,CAAC;AACJ,CAAC;AAED,eAAeR,MAAM"},"metadata":{},"sourceType":"module","externalDependencies":[]}