{"ast":null,"code":"/**\n * Internal support for selecting messages to render, with placeholder\n * interpolation and locale-aware number formatting and pluralisation\n *\n * @class\n * @private\n * @param {Object<string, unknown>} translations - Key-value pairs of the translation strings to use.\n * @param {object} [config] - Configuration options for the function.\n * @param {string} [config.locale] - An overriding locale for the PluralRules functionality.\n */\nfunction I18n(translations, config) {\n  // Make list of translations available throughout function\n  this.translations = translations || {};\n\n  // The locale to use for PluralRules and NumberFormat\n  this.locale = config && config.locale || document.documentElement.lang || 'en';\n}\n\n/**\n * The most used function - takes the key for a given piece of UI text and\n * returns the appropriate string.\n *\n * @param {string} lookupKey - The lookup key of the string to use.\n * @param {Object<string, unknown>} [options] - Any options passed with the translation string, e.g: for string interpolation.\n * @returns {string} The appropriate translation string.\n * @throws {Error} Lookup key required\n * @throws {Error} Options required for `${}` placeholders\n */\nI18n.prototype.t = function (lookupKey, options) {\n  if (!lookupKey) {\n    // Print a console error if no lookup key has been provided\n    throw new Error('i18n: lookup key missing');\n  }\n\n  // If the `count` option is set, determine which plural suffix is needed and\n  // change the lookupKey to match. We check to see if it's numeric instead of\n  // falsy, as this could legitimately be 0.\n  if (options && typeof options.count === 'number') {\n    // Get the plural suffix\n    lookupKey = lookupKey + '.' + this.getPluralSuffix(lookupKey, options.count);\n  }\n\n  // Fetch the translation string for that lookup key\n  var translationString = this.translations[lookupKey];\n  if (typeof translationString === 'string') {\n    // Check for ${} placeholders in the translation string\n    if (translationString.match(/%{(.\\S+)}/)) {\n      if (!options) {\n        throw new Error('i18n: cannot replace placeholders in string if no option data provided');\n      }\n      return this.replacePlaceholders(translationString, options);\n    } else {\n      return translationString;\n    }\n  } else {\n    // If the key wasn't found in our translations object,\n    // return the lookup key itself as the fallback\n    return lookupKey;\n  }\n};\n\n/**\n * Takes a translation string with placeholders, and replaces the placeholders\n * with the provided data\n *\n * @param {string} translationString - The translation string\n * @param {Object<string, unknown>} options - Any options passed with the translation string, e.g: for string interpolation.\n * @returns {string} The translation string to output, with ${} placeholders replaced\n */\nI18n.prototype.replacePlaceholders = function (translationString, options) {\n  /** @type {Intl.NumberFormat | undefined} */\n  var formatter;\n  if (this.hasIntlNumberFormatSupport()) {\n    formatter = new Intl.NumberFormat(this.locale);\n  }\n  return translationString.replace(/%{(.\\S+)}/g,\n  /**\n   * Replace translation string placeholders\n   *\n   * @param {string} placeholderWithBraces - Placeholder with braces\n   * @param {string} placeholderKey - Placeholder key\n   * @returns {string} Placeholder value\n   */\n  function (placeholderWithBraces, placeholderKey) {\n    if (Object.prototype.hasOwnProperty.call(options, placeholderKey)) {\n      var placeholderValue = options[placeholderKey];\n\n      // If a user has passed `false` as the value for the placeholder\n      // treat it as though the value should not be displayed\n      if (placeholderValue === false || typeof placeholderValue !== 'number' && typeof placeholderValue !== 'string') {\n        return '';\n      }\n\n      // If the placeholder's value is a number, localise the number formatting\n      if (typeof placeholderValue === 'number') {\n        return formatter ? formatter.format(placeholderValue) : placeholderValue.toString();\n      }\n      return placeholderValue;\n    } else {\n      throw new Error('i18n: no data found to replace ' + placeholderWithBraces + ' placeholder in string');\n    }\n  });\n};\n\n/**\n * Check to see if the browser supports Intl and Intl.PluralRules.\n *\n * It requires all conditions to be met in order to be supported:\n * - The browser supports the Intl class (true in IE11)\n * - The implementation of Intl supports PluralRules (NOT true in IE11)\n * - The browser/OS has plural rules for the current locale (browser dependent)\n *\n * @returns {boolean} Returns true if all conditions are met. Returns false otherwise.\n */\nI18n.prototype.hasIntlPluralRulesSupport = function () {\n  return Boolean(window.Intl && 'PluralRules' in window.Intl && Intl.PluralRules.supportedLocalesOf(this.locale).length);\n};\n\n/**\n * Check to see if the browser supports Intl and Intl.NumberFormat.\n *\n * It requires all conditions to be met in order to be supported:\n * - The browser supports the Intl class (true in IE11)\n * - The implementation of Intl supports NumberFormat (also true in IE11)\n * - The browser/OS has number formatting rules for the current locale (browser dependent)\n *\n * @returns {boolean} Returns true if all conditions are met. Returns false otherwise.\n */\nI18n.prototype.hasIntlNumberFormatSupport = function () {\n  return Boolean(window.Intl && 'NumberFormat' in window.Intl && Intl.NumberFormat.supportedLocalesOf(this.locale).length);\n};\n\n/**\n * Get the appropriate suffix for the plural form.\n *\n * Uses Intl.PluralRules (or our own fallback implementation) to get the\n * 'preferred' form to use for the given count.\n *\n * Checks that a translation has been provided for that plural form – if it\n * hasn't, it'll fall back to the 'other' plural form (unless that doesn't exist\n * either, in which case an error will be thrown)\n *\n * @param {string} lookupKey - The lookup key of the string to use.\n * @param {number} count - Number used to determine which pluralisation to use.\n * @returns {PluralRule} The suffix associated with the correct pluralisation for this locale.\n * @throws {Error} Plural form `.other` required when preferred plural form is missing\n */\nI18n.prototype.getPluralSuffix = function (lookupKey, count) {\n  // Validate that the number is actually a number.\n  //\n  // Number(count) will turn anything that can't be converted to a Number type\n  // into 'NaN'. isFinite filters out NaN, as it isn't a finite number.\n  count = Number(count);\n  if (!isFinite(count)) {\n    return 'other';\n  }\n  var preferredForm;\n\n  // Check to verify that all the requirements for Intl.PluralRules are met.\n  // If so, we can use that instead of our custom implementation. Otherwise,\n  // use the hardcoded fallback.\n  if (this.hasIntlPluralRulesSupport()) {\n    preferredForm = new Intl.PluralRules(this.locale).select(count);\n  } else {\n    preferredForm = this.selectPluralFormUsingFallbackRules(count);\n  }\n\n  // Use the correct plural form if provided\n  if (lookupKey + '.' + preferredForm in this.translations) {\n    return preferredForm;\n    // Fall back to `other` if the plural form is missing, but log a warning\n    // to the console\n  } else if (lookupKey + '.other' in this.translations) {\n    if (console && 'warn' in console) {\n      console.warn('i18n: Missing plural form \".' + preferredForm + '\" for \"' + this.locale + '\" locale. Falling back to \".other\".');\n    }\n    return 'other';\n    // If the required `other` plural form is missing, all we can do is error\n  } else {\n    throw new Error('i18n: Plural form \".other\" is required for \"' + this.locale + '\" locale');\n  }\n};\n\n/**\n * Get the plural form using our fallback implementation\n *\n * This is split out into a separate function to make it easier to test the\n * fallback behaviour in an environment where Intl.PluralRules exists.\n *\n * @param {number} count - Number used to determine which pluralisation to use.\n * @returns {PluralRule} The pluralisation form for count in this locale.\n */\nI18n.prototype.selectPluralFormUsingFallbackRules = function (count) {\n  // Currently our custom code can only handle positive integers, so let's\n  // make sure our number is one of those.\n  count = Math.abs(Math.floor(count));\n  var ruleset = this.getPluralRulesForLocale();\n  if (ruleset) {\n    return I18n.pluralRules[ruleset](count);\n  }\n  return 'other';\n};\n\n/**\n * Work out which pluralisation rules to use for the current locale\n *\n * The locale may include a regional indicator (such as en-GB), but we don't\n * usually care about this part, as pluralisation rules are usually the same\n * regardless of region. There are exceptions, however, (e.g. Portuguese) so\n * this searches by both the full and shortened locale codes, just to be sure.\n *\n * @returns {string | undefined} The name of the pluralisation rule to use (a key for one\n *   of the functions in this.pluralRules)\n */\nI18n.prototype.getPluralRulesForLocale = function () {\n  var locale = this.locale;\n  var localeShort = locale.split('-')[0];\n\n  // Look through the plural rules map to find which `pluralRule` is\n  // appropriate for our current `locale`.\n  for (var pluralRule in I18n.pluralRulesMap) {\n    if (Object.prototype.hasOwnProperty.call(I18n.pluralRulesMap, pluralRule)) {\n      var languages = I18n.pluralRulesMap[pluralRule];\n      for (var i = 0; i < languages.length; i++) {\n        if (languages[i] === locale || languages[i] === localeShort) {\n          return pluralRule;\n        }\n      }\n    }\n  }\n};\n\n/**\n * Map of plural rules to languages where those rules apply.\n *\n * Note: These groups are named for the most dominant or recognisable language\n * that uses each system. The groupings do not imply that the languages are\n * related to one another. Many languages have evolved the same systems\n * independently of one another.\n *\n * Code to support more languages can be found in the i18n spike:\n * {@link https://github.com/alphagov/govuk-frontend/blob/spike-i18n-support/src/govuk/i18n.mjs}\n *\n * Languages currently supported:\n *\n * Arabic: Arabic (ar)\n * Chinese: Burmese (my), Chinese (zh), Indonesian (id), Japanese (ja),\n *   Javanese (jv), Korean (ko), Malay (ms), Thai (th), Vietnamese (vi)\n * French: Armenian (hy), Bangla (bn), French (fr), Gujarati (gu), Hindi (hi),\n *   Persian Farsi (fa), Punjabi (pa), Zulu (zu)\n * German: Afrikaans (af), Albanian (sq), Azerbaijani (az), Basque (eu),\n *   Bulgarian (bg), Catalan (ca), Danish (da), Dutch (nl), English (en),\n *   Estonian (et), Finnish (fi), Georgian (ka), German (de), Greek (el),\n *   Hungarian (hu), Luxembourgish (lb), Norwegian (no), Somali (so),\n *   Swahili (sw), Swedish (sv), Tamil (ta), Telugu (te), Turkish (tr),\n *   Urdu (ur)\n * Irish: Irish Gaelic (ga)\n * Russian: Russian (ru), Ukrainian (uk)\n * Scottish: Scottish Gaelic (gd)\n * Spanish: European Portuguese (pt-PT), Italian (it), Spanish (es)\n * Welsh: Welsh (cy)\n *\n * @type {Object<string, string[]>}\n */\nI18n.pluralRulesMap = {\n  arabic: ['ar'],\n  chinese: ['my', 'zh', 'id', 'ja', 'jv', 'ko', 'ms', 'th', 'vi'],\n  french: ['hy', 'bn', 'fr', 'gu', 'hi', 'fa', 'pa', 'zu'],\n  german: ['af', 'sq', 'az', 'eu', 'bg', 'ca', 'da', 'nl', 'en', 'et', 'fi', 'ka', 'de', 'el', 'hu', 'lb', 'no', 'so', 'sw', 'sv', 'ta', 'te', 'tr', 'ur'],\n  irish: ['ga'],\n  russian: ['ru', 'uk'],\n  scottish: ['gd'],\n  spanish: ['pt-PT', 'it', 'es'],\n  welsh: ['cy']\n};\n\n/**\n * Different pluralisation rule sets\n *\n * Returns the appropriate suffix for the plural form associated with `n`.\n * Possible suffixes: 'zero', 'one', 'two', 'few', 'many', 'other' (the actual\n * meaning of each differs per locale). 'other' should always exist, even in\n * languages without plurals, such as Chinese.\n * {@link https://cldr.unicode.org/index/cldr-spec/plural-rules}\n *\n * The count must be a positive integer. Negative numbers and decimals aren't accounted for\n *\n * @type {Object<string, function(number): PluralRule>}\n */\nI18n.pluralRules = {\n  /* eslint-disable jsdoc/require-jsdoc */\n  arabic: function (n) {\n    if (n === 0) {\n      return 'zero';\n    }\n    if (n === 1) {\n      return 'one';\n    }\n    if (n === 2) {\n      return 'two';\n    }\n    if (n % 100 >= 3 && n % 100 <= 10) {\n      return 'few';\n    }\n    if (n % 100 >= 11 && n % 100 <= 99) {\n      return 'many';\n    }\n    return 'other';\n  },\n  chinese: function () {\n    return 'other';\n  },\n  french: function (n) {\n    return n === 0 || n === 1 ? 'one' : 'other';\n  },\n  german: function (n) {\n    return n === 1 ? 'one' : 'other';\n  },\n  irish: function (n) {\n    if (n === 1) {\n      return 'one';\n    }\n    if (n === 2) {\n      return 'two';\n    }\n    if (n >= 3 && n <= 6) {\n      return 'few';\n    }\n    if (n >= 7 && n <= 10) {\n      return 'many';\n    }\n    return 'other';\n  },\n  russian: function (n) {\n    var lastTwo = n % 100;\n    var last = lastTwo % 10;\n    if (last === 1 && lastTwo !== 11) {\n      return 'one';\n    }\n    if (last >= 2 && last <= 4 && !(lastTwo >= 12 && lastTwo <= 14)) {\n      return 'few';\n    }\n    if (last === 0 || last >= 5 && last <= 9 || lastTwo >= 11 && lastTwo <= 14) {\n      return 'many';\n    }\n    // Note: The 'other' suffix is only used by decimal numbers in Russian.\n    // We don't anticipate it being used, but it's here for consistency.\n    return 'other';\n  },\n  scottish: function (n) {\n    if (n === 1 || n === 11) {\n      return 'one';\n    }\n    if (n === 2 || n === 12) {\n      return 'two';\n    }\n    if (n >= 3 && n <= 10 || n >= 13 && n <= 19) {\n      return 'few';\n    }\n    return 'other';\n  },\n  spanish: function (n) {\n    if (n === 1) {\n      return 'one';\n    }\n    if (n % 1000000 === 0 && n !== 0) {\n      return 'many';\n    }\n    return 'other';\n  },\n  welsh: function (n) {\n    if (n === 0) {\n      return 'zero';\n    }\n    if (n === 1) {\n      return 'one';\n    }\n    if (n === 2) {\n      return 'two';\n    }\n    if (n === 3) {\n      return 'few';\n    }\n    if (n === 6) {\n      return 'many';\n    }\n    return 'other';\n  }\n  /* eslint-enable jsdoc/require-jsdoc */\n};\n\n/**\n * Plural rule category mnemonic tags\n *\n * @typedef {'zero' | 'one' | 'two' | 'few' | 'many' | 'other'} PluralRule\n */\n\n/**\n * Translated message by plural rule they correspond to.\n *\n * Allows to group pluralised messages under a single key when passing\n * translations to a component's constructor\n *\n * @typedef {object} TranslationPluralForms\n * @property {string} [other] - General plural form\n * @property {string} [zero] - Plural form used with 0\n * @property {string} [one] - Plural form used with 1\n * @property {string} [two] - Plural form used with 2\n * @property {string} [few] - Plural form used for a few\n * @property {string} [many] - Plural form used for many\n */\n\nexport { I18n };","map":{"version":3,"names":["I18n","translations","config","locale","document","documentElement","lang","prototype","t","lookupKey","options","Error","count","getPluralSuffix","translationString","match","replacePlaceholders","formatter","hasIntlNumberFormatSupport","Intl","NumberFormat","replace","placeholderWithBraces","placeholderKey","Object","hasOwnProperty","call","placeholderValue","format","toString","hasIntlPluralRulesSupport","Boolean","window","PluralRules","supportedLocalesOf","length","Number","isFinite","preferredForm","select","selectPluralFormUsingFallbackRules","console","warn","Math","abs","floor","ruleset","getPluralRulesForLocale","pluralRules","localeShort","split","pluralRule","pluralRulesMap","languages","i","arabic","chinese","french","german","irish","russian","scottish","spanish","welsh","n","lastTwo","last"],"sources":["C:\\Users\\thami\\Documents\\21W- Local Software Dev Group Project\\medicalRecordsV2\\node_modules\\src\\govuk\\i18n.mjs"],"sourcesContent":["/**\n * Internal support for selecting messages to render, with placeholder\n * interpolation and locale-aware number formatting and pluralisation\n *\n * @class\n * @private\n * @param {Object<string, unknown>} translations - Key-value pairs of the translation strings to use.\n * @param {object} [config] - Configuration options for the function.\n * @param {string} [config.locale] - An overriding locale for the PluralRules functionality.\n */\nexport function I18n (translations, config) {\n  // Make list of translations available throughout function\n  this.translations = translations || {}\n\n  // The locale to use for PluralRules and NumberFormat\n  this.locale = (config && config.locale) || document.documentElement.lang || 'en'\n}\n\n/**\n * The most used function - takes the key for a given piece of UI text and\n * returns the appropriate string.\n *\n * @param {string} lookupKey - The lookup key of the string to use.\n * @param {Object<string, unknown>} [options] - Any options passed with the translation string, e.g: for string interpolation.\n * @returns {string} The appropriate translation string.\n * @throws {Error} Lookup key required\n * @throws {Error} Options required for `${}` placeholders\n */\nI18n.prototype.t = function (lookupKey, options) {\n  if (!lookupKey) {\n    // Print a console error if no lookup key has been provided\n    throw new Error('i18n: lookup key missing')\n  }\n\n  // If the `count` option is set, determine which plural suffix is needed and\n  // change the lookupKey to match. We check to see if it's numeric instead of\n  // falsy, as this could legitimately be 0.\n  if (options && typeof options.count === 'number') {\n    // Get the plural suffix\n    lookupKey = lookupKey + '.' + this.getPluralSuffix(lookupKey, options.count)\n  }\n\n  // Fetch the translation string for that lookup key\n  var translationString = this.translations[lookupKey]\n\n  if (typeof translationString === 'string') {\n    // Check for ${} placeholders in the translation string\n    if (translationString.match(/%{(.\\S+)}/)) {\n      if (!options) {\n        throw new Error('i18n: cannot replace placeholders in string if no option data provided')\n      }\n\n      return this.replacePlaceholders(translationString, options)\n    } else {\n      return translationString\n    }\n  } else {\n    // If the key wasn't found in our translations object,\n    // return the lookup key itself as the fallback\n    return lookupKey\n  }\n}\n\n/**\n * Takes a translation string with placeholders, and replaces the placeholders\n * with the provided data\n *\n * @param {string} translationString - The translation string\n * @param {Object<string, unknown>} options - Any options passed with the translation string, e.g: for string interpolation.\n * @returns {string} The translation string to output, with ${} placeholders replaced\n */\nI18n.prototype.replacePlaceholders = function (translationString, options) {\n  /** @type {Intl.NumberFormat | undefined} */\n  var formatter\n\n  if (this.hasIntlNumberFormatSupport()) {\n    formatter = new Intl.NumberFormat(this.locale)\n  }\n\n  return translationString.replace(\n    /%{(.\\S+)}/g,\n\n    /**\n     * Replace translation string placeholders\n     *\n     * @param {string} placeholderWithBraces - Placeholder with braces\n     * @param {string} placeholderKey - Placeholder key\n     * @returns {string} Placeholder value\n     */\n    function (placeholderWithBraces, placeholderKey) {\n      if (Object.prototype.hasOwnProperty.call(options, placeholderKey)) {\n        var placeholderValue = options[placeholderKey]\n\n        // If a user has passed `false` as the value for the placeholder\n        // treat it as though the value should not be displayed\n        if (placeholderValue === false || (\n          typeof placeholderValue !== 'number' &&\n          typeof placeholderValue !== 'string')\n        ) {\n          return ''\n        }\n\n        // If the placeholder's value is a number, localise the number formatting\n        if (typeof placeholderValue === 'number') {\n          return formatter ? formatter.format(placeholderValue) : placeholderValue.toString()\n        }\n\n        return placeholderValue\n      } else {\n        throw new Error('i18n: no data found to replace ' + placeholderWithBraces + ' placeholder in string')\n      }\n    })\n}\n\n/**\n * Check to see if the browser supports Intl and Intl.PluralRules.\n *\n * It requires all conditions to be met in order to be supported:\n * - The browser supports the Intl class (true in IE11)\n * - The implementation of Intl supports PluralRules (NOT true in IE11)\n * - The browser/OS has plural rules for the current locale (browser dependent)\n *\n * @returns {boolean} Returns true if all conditions are met. Returns false otherwise.\n */\nI18n.prototype.hasIntlPluralRulesSupport = function () {\n  return Boolean(window.Intl && ('PluralRules' in window.Intl && Intl.PluralRules.supportedLocalesOf(this.locale).length))\n}\n\n/**\n * Check to see if the browser supports Intl and Intl.NumberFormat.\n *\n * It requires all conditions to be met in order to be supported:\n * - The browser supports the Intl class (true in IE11)\n * - The implementation of Intl supports NumberFormat (also true in IE11)\n * - The browser/OS has number formatting rules for the current locale (browser dependent)\n *\n * @returns {boolean} Returns true if all conditions are met. Returns false otherwise.\n */\nI18n.prototype.hasIntlNumberFormatSupport = function () {\n  return Boolean(window.Intl && ('NumberFormat' in window.Intl && Intl.NumberFormat.supportedLocalesOf(this.locale).length))\n}\n\n/**\n * Get the appropriate suffix for the plural form.\n *\n * Uses Intl.PluralRules (or our own fallback implementation) to get the\n * 'preferred' form to use for the given count.\n *\n * Checks that a translation has been provided for that plural form – if it\n * hasn't, it'll fall back to the 'other' plural form (unless that doesn't exist\n * either, in which case an error will be thrown)\n *\n * @param {string} lookupKey - The lookup key of the string to use.\n * @param {number} count - Number used to determine which pluralisation to use.\n * @returns {PluralRule} The suffix associated with the correct pluralisation for this locale.\n * @throws {Error} Plural form `.other` required when preferred plural form is missing\n */\nI18n.prototype.getPluralSuffix = function (lookupKey, count) {\n  // Validate that the number is actually a number.\n  //\n  // Number(count) will turn anything that can't be converted to a Number type\n  // into 'NaN'. isFinite filters out NaN, as it isn't a finite number.\n  count = Number(count)\n  if (!isFinite(count)) { return 'other' }\n\n  var preferredForm\n\n  // Check to verify that all the requirements for Intl.PluralRules are met.\n  // If so, we can use that instead of our custom implementation. Otherwise,\n  // use the hardcoded fallback.\n  if (this.hasIntlPluralRulesSupport()) {\n    preferredForm = new Intl.PluralRules(this.locale).select(count)\n  } else {\n    preferredForm = this.selectPluralFormUsingFallbackRules(count)\n  }\n\n  // Use the correct plural form if provided\n  if (lookupKey + '.' + preferredForm in this.translations) {\n    return preferredForm\n  // Fall back to `other` if the plural form is missing, but log a warning\n  // to the console\n  } else if (lookupKey + '.other' in this.translations) {\n    if (console && 'warn' in console) {\n      console.warn('i18n: Missing plural form \".' + preferredForm + '\" for \"' +\n        this.locale + '\" locale. Falling back to \".other\".')\n    }\n\n    return 'other'\n  // If the required `other` plural form is missing, all we can do is error\n  } else {\n    throw new Error(\n      'i18n: Plural form \".other\" is required for \"' + this.locale + '\" locale'\n    )\n  }\n}\n\n/**\n * Get the plural form using our fallback implementation\n *\n * This is split out into a separate function to make it easier to test the\n * fallback behaviour in an environment where Intl.PluralRules exists.\n *\n * @param {number} count - Number used to determine which pluralisation to use.\n * @returns {PluralRule} The pluralisation form for count in this locale.\n */\nI18n.prototype.selectPluralFormUsingFallbackRules = function (count) {\n  // Currently our custom code can only handle positive integers, so let's\n  // make sure our number is one of those.\n  count = Math.abs(Math.floor(count))\n\n  var ruleset = this.getPluralRulesForLocale()\n\n  if (ruleset) {\n    return I18n.pluralRules[ruleset](count)\n  }\n\n  return 'other'\n}\n\n/**\n * Work out which pluralisation rules to use for the current locale\n *\n * The locale may include a regional indicator (such as en-GB), but we don't\n * usually care about this part, as pluralisation rules are usually the same\n * regardless of region. There are exceptions, however, (e.g. Portuguese) so\n * this searches by both the full and shortened locale codes, just to be sure.\n *\n * @returns {string | undefined} The name of the pluralisation rule to use (a key for one\n *   of the functions in this.pluralRules)\n */\nI18n.prototype.getPluralRulesForLocale = function () {\n  var locale = this.locale\n  var localeShort = locale.split('-')[0]\n\n  // Look through the plural rules map to find which `pluralRule` is\n  // appropriate for our current `locale`.\n  for (var pluralRule in I18n.pluralRulesMap) {\n    if (Object.prototype.hasOwnProperty.call(I18n.pluralRulesMap, pluralRule)) {\n      var languages = I18n.pluralRulesMap[pluralRule]\n      for (var i = 0; i < languages.length; i++) {\n        if (languages[i] === locale || languages[i] === localeShort) {\n          return pluralRule\n        }\n      }\n    }\n  }\n}\n\n/**\n * Map of plural rules to languages where those rules apply.\n *\n * Note: These groups are named for the most dominant or recognisable language\n * that uses each system. The groupings do not imply that the languages are\n * related to one another. Many languages have evolved the same systems\n * independently of one another.\n *\n * Code to support more languages can be found in the i18n spike:\n * {@link https://github.com/alphagov/govuk-frontend/blob/spike-i18n-support/src/govuk/i18n.mjs}\n *\n * Languages currently supported:\n *\n * Arabic: Arabic (ar)\n * Chinese: Burmese (my), Chinese (zh), Indonesian (id), Japanese (ja),\n *   Javanese (jv), Korean (ko), Malay (ms), Thai (th), Vietnamese (vi)\n * French: Armenian (hy), Bangla (bn), French (fr), Gujarati (gu), Hindi (hi),\n *   Persian Farsi (fa), Punjabi (pa), Zulu (zu)\n * German: Afrikaans (af), Albanian (sq), Azerbaijani (az), Basque (eu),\n *   Bulgarian (bg), Catalan (ca), Danish (da), Dutch (nl), English (en),\n *   Estonian (et), Finnish (fi), Georgian (ka), German (de), Greek (el),\n *   Hungarian (hu), Luxembourgish (lb), Norwegian (no), Somali (so),\n *   Swahili (sw), Swedish (sv), Tamil (ta), Telugu (te), Turkish (tr),\n *   Urdu (ur)\n * Irish: Irish Gaelic (ga)\n * Russian: Russian (ru), Ukrainian (uk)\n * Scottish: Scottish Gaelic (gd)\n * Spanish: European Portuguese (pt-PT), Italian (it), Spanish (es)\n * Welsh: Welsh (cy)\n *\n * @type {Object<string, string[]>}\n */\nI18n.pluralRulesMap = {\n  arabic: ['ar'],\n  chinese: ['my', 'zh', 'id', 'ja', 'jv', 'ko', 'ms', 'th', 'vi'],\n  french: ['hy', 'bn', 'fr', 'gu', 'hi', 'fa', 'pa', 'zu'],\n  german: [\n    'af', 'sq', 'az', 'eu', 'bg', 'ca', 'da', 'nl', 'en', 'et', 'fi', 'ka',\n    'de', 'el', 'hu', 'lb', 'no', 'so', 'sw', 'sv', 'ta', 'te', 'tr', 'ur'\n  ],\n  irish: ['ga'],\n  russian: ['ru', 'uk'],\n  scottish: ['gd'],\n  spanish: ['pt-PT', 'it', 'es'],\n  welsh: ['cy']\n}\n\n/**\n * Different pluralisation rule sets\n *\n * Returns the appropriate suffix for the plural form associated with `n`.\n * Possible suffixes: 'zero', 'one', 'two', 'few', 'many', 'other' (the actual\n * meaning of each differs per locale). 'other' should always exist, even in\n * languages without plurals, such as Chinese.\n * {@link https://cldr.unicode.org/index/cldr-spec/plural-rules}\n *\n * The count must be a positive integer. Negative numbers and decimals aren't accounted for\n *\n * @type {Object<string, function(number): PluralRule>}\n */\nI18n.pluralRules = {\n  /* eslint-disable jsdoc/require-jsdoc */\n  arabic: function (n) {\n    if (n === 0) { return 'zero' }\n    if (n === 1) { return 'one' }\n    if (n === 2) { return 'two' }\n    if (n % 100 >= 3 && n % 100 <= 10) { return 'few' }\n    if (n % 100 >= 11 && n % 100 <= 99) { return 'many' }\n    return 'other'\n  },\n  chinese: function () {\n    return 'other'\n  },\n  french: function (n) {\n    return n === 0 || n === 1 ? 'one' : 'other'\n  },\n  german: function (n) {\n    return n === 1 ? 'one' : 'other'\n  },\n  irish: function (n) {\n    if (n === 1) { return 'one' }\n    if (n === 2) { return 'two' }\n    if (n >= 3 && n <= 6) { return 'few' }\n    if (n >= 7 && n <= 10) { return 'many' }\n    return 'other'\n  },\n  russian: function (n) {\n    var lastTwo = n % 100\n    var last = lastTwo % 10\n    if (last === 1 && lastTwo !== 11) { return 'one' }\n    if (last >= 2 && last <= 4 && !(lastTwo >= 12 && lastTwo <= 14)) { return 'few' }\n    if (last === 0 || (last >= 5 && last <= 9) || (lastTwo >= 11 && lastTwo <= 14)) { return 'many' }\n    // Note: The 'other' suffix is only used by decimal numbers in Russian.\n    // We don't anticipate it being used, but it's here for consistency.\n    return 'other'\n  },\n  scottish: function (n) {\n    if (n === 1 || n === 11) { return 'one' }\n    if (n === 2 || n === 12) { return 'two' }\n    if ((n >= 3 && n <= 10) || (n >= 13 && n <= 19)) { return 'few' }\n    return 'other'\n  },\n  spanish: function (n) {\n    if (n === 1) { return 'one' }\n    if (n % 1000000 === 0 && n !== 0) { return 'many' }\n    return 'other'\n  },\n  welsh: function (n) {\n    if (n === 0) { return 'zero' }\n    if (n === 1) { return 'one' }\n    if (n === 2) { return 'two' }\n    if (n === 3) { return 'few' }\n    if (n === 6) { return 'many' }\n    return 'other'\n  }\n  /* eslint-enable jsdoc/require-jsdoc */\n}\n\n/**\n * Plural rule category mnemonic tags\n *\n * @typedef {'zero' | 'one' | 'two' | 'few' | 'many' | 'other'} PluralRule\n */\n\n/**\n * Translated message by plural rule they correspond to.\n *\n * Allows to group pluralised messages under a single key when passing\n * translations to a component's constructor\n *\n * @typedef {object} TranslationPluralForms\n * @property {string} [other] - General plural form\n * @property {string} [zero] - Plural form used with 0\n * @property {string} [one] - Plural form used with 1\n * @property {string} [two] - Plural form used with 2\n * @property {string} [few] - Plural form used for a few\n * @property {string} [many] - Plural form used for many\n */\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}