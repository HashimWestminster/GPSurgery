{"ast":null,"code":"/**\n * Common helpers which do not require polyfill.\n *\n * IMPORTANT: If a helper require a polyfill, please isolate it in its own module\n * so that the polyfill can be properly tree-shaken and does not burden\n * the components that do not need that helper\n *\n * @module common/index\n */\n\n/**\n * TODO: Ideally this would be a NodeList.prototype.forEach polyfill\n * This seems to fail in IE8, requires more investigation.\n * See: https://github.com/imagitama/nodelist-foreach-polyfill\n *\n * @deprecated Will be made private in v5.0\n * @template {Node} ElementType\n * @param {NodeListOf<ElementType>} nodes - NodeList from querySelectorAll()\n * @param {nodeListIterator<ElementType>} callback - Callback function to run for each node\n * @returns {void}\n */\nfunction nodeListForEach(nodes, callback) {\n  if (window.NodeList.prototype.forEach) {\n    return nodes.forEach(callback);\n  }\n  for (var i = 0; i < nodes.length; i++) {\n    callback.call(window, nodes[i], i, nodes);\n  }\n}\n\n/**\n * Used to generate a unique string, allows multiple instances of the component\n * without them conflicting with each other.\n * https://stackoverflow.com/a/8809472\n *\n * @deprecated Will be made private in v5.0\n * @returns {string} Unique ID\n */\nfunction generateUniqueID() {\n  var d = new Date().getTime();\n  if (typeof window.performance !== 'undefined' && typeof window.performance.now === 'function') {\n    d += window.performance.now(); // use high-precision timer if available\n  }\n\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    var r = (d + Math.random() * 16) % 16 | 0;\n    d = Math.floor(d / 16);\n    return (c === 'x' ? r : r & 0x3 | 0x8).toString(16);\n  });\n}\n\n/**\n * Config flattening function\n *\n * Takes any number of objects, flattens them into namespaced key-value pairs,\n * (e.g. {'i18n.showSection': 'Show section'}) and combines them together, with\n * greatest priority on the LAST item passed in.\n *\n * @deprecated Will be made private in v5.0\n * @returns {Object<string, unknown>} A flattened object of key-value pairs.\n */\nfunction mergeConfigs( /* configObject1, configObject2, ...configObjects */\n) {\n  /**\n   * Function to take nested objects and flatten them to a dot-separated keyed\n   * object. Doing this means we don't need to do any deep/recursive merging of\n   * each of our objects, nor transform our dataset from a flat list into a\n   * nested object.\n   *\n   * @param {Object<string, unknown>} configObject - Deeply nested object\n   * @returns {Object<string, unknown>} Flattened object with dot-separated keys\n   */\n  var flattenObject = function (configObject) {\n    // Prepare an empty return object\n    /** @type {Object<string, unknown>} */\n    var flattenedObject = {};\n\n    /**\n     * Our flattening function, this is called recursively for each level of\n     * depth in the object. At each level we prepend the previous level names to\n     * the key using `prefix`.\n     *\n     * @param {Partial<Object<string, unknown>>} obj - Object to flatten\n     * @param {string} [prefix] - Optional dot-separated prefix\n     */\n    var flattenLoop = function (obj, prefix) {\n      // Loop through keys...\n      for (var key in obj) {\n        // Check to see if this is a prototypical key/value,\n        // if it is, skip it.\n        if (!Object.prototype.hasOwnProperty.call(obj, key)) {\n          continue;\n        }\n        var value = obj[key];\n        var prefixedKey = prefix ? prefix + '.' + key : key;\n        if (typeof value === 'object') {\n          // If the value is a nested object, recurse over that too\n          flattenLoop(value, prefixedKey);\n        } else {\n          // Otherwise, add this value to our return object\n          flattenedObject[prefixedKey] = value;\n        }\n      }\n    };\n\n    // Kick off the recursive loop\n    flattenLoop(configObject);\n    return flattenedObject;\n  };\n\n  // Start with an empty object as our base\n  /** @type {Object<string, unknown>} */\n  var formattedConfigObject = {};\n\n  // Loop through each of the remaining passed objects and push their keys\n  // one-by-one into configObject. Any duplicate keys will override the existing\n  // key with the new value.\n  for (var i = 0; i < arguments.length; i++) {\n    var obj = flattenObject(arguments[i]);\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        formattedConfigObject[key] = obj[key];\n      }\n    }\n  }\n  return formattedConfigObject;\n}\n\n/**\n * Extracts keys starting with a particular namespace from a flattened config\n * object, removing the namespace in the process.\n *\n * @deprecated Will be made private in v5.0\n * @param {Object<string, unknown>} configObject - The object to extract key-value pairs from.\n * @param {string} namespace - The namespace to filter keys with.\n * @returns {Object<string, unknown>} Flattened object with dot-separated key namespace removed\n * @throws {Error} Config object required\n * @throws {Error} Namespace string required\n */\nfunction extractConfigByNamespace(configObject, namespace) {\n  // Check we have what we need\n  if (!configObject || typeof configObject !== 'object') {\n    throw new Error('Provide a `configObject` of type \"object\".');\n  }\n  if (!namespace || typeof namespace !== 'string') {\n    throw new Error('Provide a `namespace` of type \"string\" to filter the `configObject` by.');\n  }\n\n  /** @type {Object<string, unknown>} */\n  var newObject = {};\n  for (var key in configObject) {\n    // Split the key into parts, using . as our namespace separator\n    var keyParts = key.split('.');\n    // Check if the first namespace matches the configured namespace\n    if (Object.prototype.hasOwnProperty.call(configObject, key) && keyParts[0] === namespace) {\n      // Remove the first item (the namespace) from the parts array,\n      // but only if there is more than one part (we don't want blank keys!)\n      if (keyParts.length > 1) {\n        keyParts.shift();\n      }\n      // Join the remaining parts back together\n      var newKey = keyParts.join('.');\n      // Add them to our new object\n      newObject[newKey] = configObject[key];\n    }\n  }\n  return newObject;\n}\n\n/**\n * @template {Node} ElementType\n * @callback nodeListIterator\n * @param {ElementType} value - The current node being iterated on\n * @param {number} index - The current index in the iteration\n * @param {NodeListOf<ElementType>} nodes - NodeList from querySelectorAll()\n * @returns {void}\n */\n\nexport { nodeListForEach, generateUniqueID, mergeConfigs, extractConfigByNamespace };","map":{"version":3,"names":["nodeListForEach","nodes","callback","window","NodeList","prototype","forEach","i","length","call","generateUniqueID","d","Date","getTime","performance","now","replace","c","r","Math","random","floor","toString","mergeConfigs","flattenObject","configObject","flattenedObject","flattenLoop","obj","prefix","key","Object","hasOwnProperty","value","prefixedKey","formattedConfigObject","arguments","extractConfigByNamespace","namespace","Error","newObject","keyParts","split","shift","newKey","join"],"sources":["C:/Users/thami/Documents/21W- Local Software Dev Group Project/medicalRecordsV2/node_modules/govuk-frontend/govuk-esm/common/index.mjs"],"sourcesContent":["/**\n * Common helpers which do not require polyfill.\n *\n * IMPORTANT: If a helper require a polyfill, please isolate it in its own module\n * so that the polyfill can be properly tree-shaken and does not burden\n * the components that do not need that helper\n *\n * @module common/index\n */\n\n/**\n * TODO: Ideally this would be a NodeList.prototype.forEach polyfill\n * This seems to fail in IE8, requires more investigation.\n * See: https://github.com/imagitama/nodelist-foreach-polyfill\n *\n * @deprecated Will be made private in v5.0\n * @template {Node} ElementType\n * @param {NodeListOf<ElementType>} nodes - NodeList from querySelectorAll()\n * @param {nodeListIterator<ElementType>} callback - Callback function to run for each node\n * @returns {void}\n */\nfunction nodeListForEach (nodes, callback) {\n  if (window.NodeList.prototype.forEach) {\n    return nodes.forEach(callback)\n  }\n  for (var i = 0; i < nodes.length; i++) {\n    callback.call(window, nodes[i], i, nodes);\n  }\n}\n\n/**\n * Used to generate a unique string, allows multiple instances of the component\n * without them conflicting with each other.\n * https://stackoverflow.com/a/8809472\n *\n * @deprecated Will be made private in v5.0\n * @returns {string} Unique ID\n */\nfunction generateUniqueID () {\n  var d = new Date().getTime();\n  if (typeof window.performance !== 'undefined' && typeof window.performance.now === 'function') {\n    d += window.performance.now(); // use high-precision timer if available\n  }\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    var r = (d + Math.random() * 16) % 16 | 0;\n    d = Math.floor(d / 16);\n    return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16)\n  })\n}\n\n/**\n * Config flattening function\n *\n * Takes any number of objects, flattens them into namespaced key-value pairs,\n * (e.g. {'i18n.showSection': 'Show section'}) and combines them together, with\n * greatest priority on the LAST item passed in.\n *\n * @deprecated Will be made private in v5.0\n * @returns {Object<string, unknown>} A flattened object of key-value pairs.\n */\nfunction mergeConfigs (/* configObject1, configObject2, ...configObjects */) {\n  /**\n   * Function to take nested objects and flatten them to a dot-separated keyed\n   * object. Doing this means we don't need to do any deep/recursive merging of\n   * each of our objects, nor transform our dataset from a flat list into a\n   * nested object.\n   *\n   * @param {Object<string, unknown>} configObject - Deeply nested object\n   * @returns {Object<string, unknown>} Flattened object with dot-separated keys\n   */\n  var flattenObject = function (configObject) {\n    // Prepare an empty return object\n    /** @type {Object<string, unknown>} */\n    var flattenedObject = {};\n\n    /**\n     * Our flattening function, this is called recursively for each level of\n     * depth in the object. At each level we prepend the previous level names to\n     * the key using `prefix`.\n     *\n     * @param {Partial<Object<string, unknown>>} obj - Object to flatten\n     * @param {string} [prefix] - Optional dot-separated prefix\n     */\n    var flattenLoop = function (obj, prefix) {\n      // Loop through keys...\n      for (var key in obj) {\n        // Check to see if this is a prototypical key/value,\n        // if it is, skip it.\n        if (!Object.prototype.hasOwnProperty.call(obj, key)) {\n          continue\n        }\n        var value = obj[key];\n        var prefixedKey = prefix ? prefix + '.' + key : key;\n        if (typeof value === 'object') {\n          // If the value is a nested object, recurse over that too\n          flattenLoop(value, prefixedKey);\n        } else {\n          // Otherwise, add this value to our return object\n          flattenedObject[prefixedKey] = value;\n        }\n      }\n    };\n\n    // Kick off the recursive loop\n    flattenLoop(configObject);\n    return flattenedObject\n  };\n\n  // Start with an empty object as our base\n  /** @type {Object<string, unknown>} */\n  var formattedConfigObject = {};\n\n  // Loop through each of the remaining passed objects and push their keys\n  // one-by-one into configObject. Any duplicate keys will override the existing\n  // key with the new value.\n  for (var i = 0; i < arguments.length; i++) {\n    var obj = flattenObject(arguments[i]);\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        formattedConfigObject[key] = obj[key];\n      }\n    }\n  }\n\n  return formattedConfigObject\n}\n\n/**\n * Extracts keys starting with a particular namespace from a flattened config\n * object, removing the namespace in the process.\n *\n * @deprecated Will be made private in v5.0\n * @param {Object<string, unknown>} configObject - The object to extract key-value pairs from.\n * @param {string} namespace - The namespace to filter keys with.\n * @returns {Object<string, unknown>} Flattened object with dot-separated key namespace removed\n * @throws {Error} Config object required\n * @throws {Error} Namespace string required\n */\nfunction extractConfigByNamespace (configObject, namespace) {\n  // Check we have what we need\n  if (!configObject || typeof configObject !== 'object') {\n    throw new Error('Provide a `configObject` of type \"object\".')\n  }\n\n  if (!namespace || typeof namespace !== 'string') {\n    throw new Error('Provide a `namespace` of type \"string\" to filter the `configObject` by.')\n  }\n\n  /** @type {Object<string, unknown>} */\n  var newObject = {};\n\n  for (var key in configObject) {\n    // Split the key into parts, using . as our namespace separator\n    var keyParts = key.split('.');\n    // Check if the first namespace matches the configured namespace\n    if (Object.prototype.hasOwnProperty.call(configObject, key) && keyParts[0] === namespace) {\n      // Remove the first item (the namespace) from the parts array,\n      // but only if there is more than one part (we don't want blank keys!)\n      if (keyParts.length > 1) {\n        keyParts.shift();\n      }\n      // Join the remaining parts back together\n      var newKey = keyParts.join('.');\n      // Add them to our new object\n      newObject[newKey] = configObject[key];\n    }\n  }\n  return newObject\n}\n\n/**\n * @template {Node} ElementType\n * @callback nodeListIterator\n * @param {ElementType} value - The current node being iterated on\n * @param {number} index - The current index in the iteration\n * @param {NodeListOf<ElementType>} nodes - NodeList from querySelectorAll()\n * @returns {void}\n */\n\nexport { nodeListForEach, generateUniqueID, mergeConfigs, extractConfigByNamespace };\n//# sourceMappingURL=common/index.mjs.map\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}